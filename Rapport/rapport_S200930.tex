\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage[hidelinks]{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=magenta,
urlcolor=cyan,
pdfpagemode=FullScreen,
}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw,dvipsnames]{xcolor}

% Change le nom par défaut des listing
\renewcommand{\lstlistingname}{Extrait de Code}

% Change la police des titres pour convenir à votre seul lecteur
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape}
% Idem pour la table des matière.
\usepackage[nottoc,notlof,notlot]{tocbibind}
\usepackage[titles,subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\newcommand{\coms}[1]{\textcolor{MidnightBlue}{#1}}

\lstset{
    language=C, % Utilisation du langage C
    commentstyle={\color{MidnightBlue}}, % Couleur des commentaires
    frame=single, % Entoure le code d'un joli cadre
    rulecolor=\color{black}, % Couleur de la ligne qui forme le cadre
    stringstyle=\color{RawSienna}, % Couleur des chaines de caractères
    numbers=left, % Ajoute une numérotation des lignes à gauche
    numbersep=5pt, % Distance entre les numérots de lignes et le code
    numberstyle=\tiny\color{mygray}, % Couleur des numéros de lignes
    basicstyle=\tt\footnotesize,
    tabsize=3, % Largeur des tabulations par défaut
    keywordstyle=\tt\bf\footnotesize\color{Sepia}, % Style des mots-clés
    extendedchars=true,
    captionpos=b, % sets the caption-position to bottom
    texcl=true, % Commentaires sur une ligne interprétés en Latex
    showstringspaces=false, % Ne montre pas les espace dans les chaines de caractères
    escapeinside={(>}{<)}, % Permet de mettre du latex entre des <( et )>.
    inputencoding=utf8,
    literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\newcommand{\tablemat}{~}

%%%%%%%%%%%%%%%%% TITRE %%%%%%%%%%%%%%%%
% Complétez et décommentez les définitions de macros suivantes :
\newcommand{\intitule}{Projet 3 (Récursivité \& Élimination de la Récursivité)}
\newcommand{\Prenom}{Timothy}
\newcommand{\Nom}{Smeers}
\newcommand{\matricule}{S200930}
% Décommentez ceci si vous voulez une table des matières :
\renewcommand{\tablemat}{\tableofcontents}

%%%%%%%% ZONE PROTÉGÉE : MODIFIEZ UNE DES DIX PROCHAINES %%%%%%%%
%%%%%%%%            LIGNES POUR PERDRE 2 PTS.            %%%%%%%%
\title{INFO0947: \intitule}
\author{\textsc{\Prenom}~\textsc{\Nom}, \matricule}
\date{}

\begin{document}
\maketitle
\newpage
\tablemat
\newpage
%%%%%%%%%%%%%%%%%%%% FIN DE LA ZONE PROTÉGÉE %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%% RAPPORT %%%%%%%%%%%%%%%
% Complétez les sections ci-dessous

\section{Formulation Récursive}\label{formulation}

	\subsection{Notations}	
	
	$\forall ~ n ~ \in \mathbb{N} ~ , ~ n > 0 $
	\vspace{2mm}
	
	$\forall ~ case ~ \in ~ hexa ~ , ~ \exists ~ case ~ \in ~ \{0, 1, \ldots , 9, A, B, \ldots , F\}$
	\vspace{2mm}
	
	$\exists ~ l\_nextCase ~ \in ~ hexa[] ~ , ~ l\_nextCase ~ = ~ hexa ~ + ~ 1 $
	\vspace{2mm}
	
	$\exists ~ l\_position ~ \in ~ \mathbb{N} ~ , ~ l\_position = n - 1$
	\vspace{2mm}
	
	$\exists ~ l\_exposant ~ \in ~ \mathbb{N} , l\_exposant = hexa\_power(l_position);$
	\vspace{2mm}
	
	$\exists ~ (l\_convert)_{10} ~ \in ~ \mathbb{N} ~ , ~ (l\_convert)_{10} = convert(hexa[l\_position]) $
	\vspace{2mm}
	
	$\exists ~ (l\_decimal)_{10} ~ \in ~ \mathbb{N} ~ , ~ (l\_decimal)_{10} = (l\_convert)_{10} * (l\_exposant)_{10}$
	\vspace{2mm}
	
	$
	l\_size(s) = \left\{
	\begin{array}{ll}
    		0 & \mbox{si s = `` `` }  \\
    		1 + l\_size(cdr(s)) & \mbox{sinon.}
	\end{array}
	\right.
	$
	
	\subsection{Peut-on résoudre le problème récursivement ?}
	
		\begin{itemize}
			\item[$\circ$] Trois questions
			\begin{enumerate}
				\item Peut-on trouver un paramètre récursif ?
				\begin{itemize}
					\item[$\triangleright$] n
				\end{itemize}
				\item Peut-on trouver un cas de base$^{\ref{cas_base}}$ ?
				\begin{itemize}
					\item[$\triangleright$] $n = 1$
				\end{itemize}
				\item Peut-on exprimer le problème de manière récursive$^{\ref{cas_recur}}$ ?
				\begin{itemize}
					\item[$\triangleright$] Pour $decimal \in (\mathbb{N})_{10}$, on a
				\end{itemize}
			\end{enumerate} 
		\end{itemize}
		
		$
		(decimal)_{10} = \left\{
    	\begin{array}{ll}
        		l\_decimal & \mbox{si n = 1}  \\
        		l\_decimal + hexa\_dec\_rec(l\_nextCase, l\_position) & \mbox{sinon.}
    	\end{array}
		\right.
		$
	
	\subsection{Cas de base.}\label{cas_base}
	
		\begin{itemize}
			\item[$\circ$] L'expression \fbox{$ n == 1$} est la condition de terminaison.
			\item[$\circ$] L'instruction \fbox{$return (l\_decimal);$} est le cas de base.
			\item[$\circ$] L'instruction \fbox{$return (l\_decimal + (hexa\_dec\_rec(l\_nextCase, l\_position)));$} est 
							\\ l’appel récursif.
			\begin{itemize}
				\item[$\triangleright$] Puisqu’on dispose d’une invocation de la fonction $\textbf{hexa\_dec\_rec()}$ sur des 
										\\ paramètres effectif différent 
										\\ des paramètres formel $\textbf{(l\_position < n \&\& l\_nextCase > hexa)}$ 
										\\ Dit autrement, chaque appel récursif tend vers le cas de base.
			\end{itemize}
		\end{itemize}
	
	\subsection{Cas récursif.}\label{cas_recur}
	
		Nos cas récursif sont donc $\textbf{l\_position}$ et $\textbf{l\_nextCase}$ car :
		\\
		
		\begin{tabular}{|p{15cm}|c}
			\hline
			La conversion de $\textbf{hexa}$ vaut $\textbf{l\_decimal}$ si $\textbf{n = 1}$. Sinon, c'est $\textbf{l\_decimal}$ additioné par 
			\\ la conversion de $\textbf{l\_nextCase}$ dont la taille restante vaut $\textbf{l\_position}$.
			\\
			\hline
		\end{tabular}
		\\
		
		Mathématiquement, cela donne :
		
		$
		(decimal)_{10} = \left\{
    	\begin{array}{ll}
        		l\_decimal & \mbox{si n = 1}  \\
        		l\_decimal + hexa\_dec\_rec(l\_nextCase, l\_position) & \mbox{sinon.}
    	\end{array}
		\right.
		$
		

\section{Spécification}\label{specification}
%%%%%%%%%%%%%%%%%%%%%%%%%

		\begin{tabular}{|p{17cm}|c}
			\hline
			\\
			Une spécification se définit en deux temps :
			\vspace{3mm}
		
			\textbf{La PréCondition}  implémente les suppositions. Elle caractérise donc les conditions initiales du module,
			\\ les propriétés que doivent respecter les valeurs en entrée du module.
			\\ Elle se définit donc sur les paramètres formels (qui seront initialisés avec les paramètres effectifs). 
			\\ La PréCondition doit être satisfaite avant l’exécution du module.
			
			\vspace{3mm}
			
			\textbf{La PostCondition} implémente les certifications. Elle caractérise les conditions finales du résultat du
			\\ module. Dit autrement, la PostCondition décrit le résultat du module sans dire comment il a été 
			\\ obtenu. La PostCondition sera satisfaite après l’invocation.

			\\
			\hline
		\end{tabular}
		
		\vspace{5mm}
		
		\begin{itemize}
			\item[$\circ$] PréCondition $\equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} 
			\\\wedge (n = \mid \{hexa[0] - hexa[n]\}\mid) \Rightarrow (\{hexa[0],\ldots,hexa[n-1]\} \in \{0, \ldots, 9,A,\ldots,F \} 
			\\\wedge (hexa[n] = \backslash0))$	
			
			\vspace{3mm}
			\begin{itemize}
				\item[$\triangleright$] Dans ce cas de figure, ma fonction contient 4 assert qui sont représenté ci-dessus. \\
							   La première condition est que mon String soit différent de null. \\
							   Ensuite, il faut que mon `n` soit strictement supérieur à 0 car dans le cas contraire cela veux 
							   dire que mon String ne contient aucun symbole.
							   Le n doit ensuite être égale à l'amplitude de l'ensemble $\{hexa[0],\ldots, hexa[n]\}$.
							   Cela implique que l'intervale $\{hexa[0],\ldots, hexa[n-1]\}$ doit être compris dans les symboles 
							   de l'hexadécimal et le symbole à la position $hexa[n]$ devra être égale à $'\backslash0'$ 						
			\end{itemize}
			\vspace{5mm}
			
			\item[$\circ$] PostCondition $\equiv N = \sum_{i=0}^{n-1} a_i \times b^i , a_i \in \{0,1,\ldots,b-1\} \wedge N \in (\mathbb{N})_{16}$
				
			\vspace{3mm}
			\begin{itemize}
				\item[] Un système de numération d’un nombre naturel N est constitué
				\begin{enumerate}
					\item D'une base b $\in \mathbb{N} , (b > 1)$ 
					\item D'un ensemble de b symboles, appelés $chiffres$, compris entre $0$ et $b-1$.
				\end{enumerate}						
				\item[] La représentation d'un naturel N via le système de numération repose sur la structure ci-dessus
				\item[$\triangleright$] $b = 16$ et l'ensemble des symboles est $\{0,1;\ldots,9,A,\ldots,F\}$  
			\end{itemize}
		\end{itemize}
		
		\begin{lstlisting}[caption={Spécification}]
/*
 * PréCondition (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 $}<)
 *  (>\coms{$              \wedge (n = \mid \{hexa[0] - hexa[n]\}\mid) \Rightarrow (\{hexa[0],\ldots,hexa[n-1]\} \in \{0, \ldots, 9,A,\ldots,F \} $}<) 
 *  (>\coms{$              \wedge (hexa[n] = \backslash0))  $}<)
 * PostCondition (>\coms{$\equiv hexa\_dec\_rec = Hexa\_Dec\_Rec(hexa, n)
\land hexa = hexa_0 \land n = n_0 $}<)
 */
unsigned int hexa_dec_rec(char *hexa, int n);
		\end{lstlisting}


\newpage
\section{Construction Récursive}\label{recur}

	Vu que notre fonction $\textbf{hexa\_dec\_rec()}$ est une fonction récursive qui s'appuie sur une structure conditionnelle, 
	alors il nous faut une approche constructive en trois étapes
	
	\begin{enumerate}
		\item Programmation défensive.
		\item Cas de base.
		\item Cas récursif.
	\end{enumerate} 
	
	\subsection{Programmation défensive}
	
		Il s'agit d'une vérification de la PréCondition.

% hexa_dec_rec %
		\begin{lstlisting}[caption={hexa\_dec\_rec()}]
unsigned int hexa_dec_rec(char *hexa, int n) {
	assert(hexa);
	assert(n > 0);

	unsigned int l_size;
	unsigned int l_convert;

	l_size = size_char(hexa);
	l_convert = convert(hexa[0]);

	assert(n == l_size);
	assert(l_convert != -1);

    /* PréCondition (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 $}<)
    (>\coms{$                  \wedge (n = \mid \{hexa[0] - hexa[n]\}\mid) \Rightarrow (\{hexa[0],\ldots,hexa[n-1]\} \in \{0, \ldots, 9,A,\ldots,F \} $}<) 
    (>\coms{$ 				   \wedge (hexa[n] = \backslash0))  $}<) */ 
	
	... /* Reste du code */
}
		\end{lstlisting}

\newpage
		
% size_char %
		\begin{lstlisting}[caption={size\_char()}]
static unsigned int size_char(char *p_hexa) {

	unsigned int i;
	i = 0;

	while (p_hexa[i])
		i++;

	return (i);
}
		\end{lstlisting}
		
Cette fonction statique permet de Vérifiez toute position du String $p\_hexa$ 
\\ en incrémentant $i$ pour chaque valeur du String $\neq$ '\textbackslash$0$'
		
\begin{table}[!h]
\begin{tabular}{llllllll}
\multicolumn{1}{l|}{}        & 0                        & \multicolumn{1}{l|}{      }          & i                         & \multicolumn{1}{l|}{      }            & '\textbackslash{}0' &  &  \\ \cline{2-5}
\multicolumn{1}{l|}{p\_hexa} & \multicolumn{2}{l|}{\cellcolor[HTML]{FD6864}Déjà vérifié}       & \multicolumn{2}{l|}{\cellcolor[HTML]{38FFF8}Reste à vérifié}       &                     &  &  \\ \cline{2-5}
                             & \multicolumn{2}{l}{Incrémente i}                                &                           &                                        &                     &  &
\end{tabular}
\end{table}

% convert %
		\begin{lstlisting}[caption={convert()}]
static unsigned int convert(char hex) {
	switch (hex) {
	case '0':
		return (0);
	case '1':
		return (1);
	case '2':
		return (2);
	case '3':
		return (3);
	case '4':
		return (4); 
	case '5':
		return (5); 
	case '6':
		return (6); 
	case '7':
		return (7);
	case '8':
		return (8); 
	case '9':
		return (9);
	case 'A':
		return (10); 
	case 'B':
		return (11);
	case 'C':
		return (12);
	case 'D':
		return (13);
	case 'E':
		return (14);
	case 'F':
		return (15); 
	}
	return (-1);
}
		\end{lstlisting}
		
	\subsection{Cas de base}\label{cas_base_code}
	
	
	On gère le cas de base où $n = 1$. Juste avant, on gère les cas précis de la préconditon$^{\ref{specification}}$
	
		\begin{lstlisting}[caption={Cas de base}]
	
	/* PréCondition (>\coms{$ \equiv (hexa \neq NULL) \wedge n > 0 $}<) 
	 (>\coms{$                \wedge (n = \mid \{hexa[0] - hexa[n]\}\mid) \Rightarrow (\{hexa[0],\ldots,hexa[n-1]\} \in \{0, \ldots, 9,A,\ldots,F\} $}<)  
     (>\coms{$      	      \wedge (hexa[n] = \backslash0)) $}<) */

	if (n == 1)
		/* (>\coms{$ \{n = 1 \Rightarrow hexa \neq NULL\} $}<) */
		return (l_decimal);
		/* (>\coms{$  \{n = n_0 \wedge hexa = hexa_0 \wedge hexa\_dec\_rec = l\_decimal\}  $}<) */
		/* (>\coms{$  \{\Rightarrow POSTCONDITION\}  $}<) */

		\end{lstlisting}
				
	\subsection{Cas récursif}
	
		On gère le cas de base où $n > 1$. Juste avant, on gère les cas précis du cas de base $^{\ref{cas_base_code}}$ et de la précondition$^{\ref{specification}}$
	
		\begin{lstlisting}[caption={Cas récursif}]
	
	/* PréCondition (>\coms{$ \equiv (hexa \neq NULL) \wedge n > 0 $}<) 
	 (>\coms{$                \wedge (n = \mid \{hexa[0] - hexa[n]\}\mid) \Rightarrow (\{hexa[0],\ldots,hexa[n-1]\} \in \{0, \ldots, 9,A,\ldots,F\} $}<)  
     (>\coms{$      	      \wedge (hexa[n] = \backslash0)) $}<) */

	/* (>\coms{$ \{n > 1 \Rightarrow hexa \neq NULL\} $}<) */
	return (l_decimal + (hexa_dec_rec(l_nextCase, l_position)));
	/* (>\coms{$  \{n \neq n_0 \wedge hexa = hexa_0 \wedge hexa\_dec\_rec = l\_decimal + (hexa\_dec\_rec(l\_nextCase, l\_position))\}  $}<) */
	/* (>\coms{$  \{\Rightarrow POSTCONDITION\}  $}<) */

		\end{lstlisting}

\section{Traces d'Exécution}\label{traces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fournissez et discutez ici les traces d'exécution de la fonction romain_rec()
% pour les exemples donnés dans l'énoncé
% 
% 
% L'exemple ci-dessous donne une trace d'exécution pour un exercice sur les
% Piles (cfr. GameCodes associés).  Inspirez-vous du code LaTeX pour produire
% vos traces d'exécution.
\begin{tabular}{|c|}
\\
\\
\textcolor{white}{--}\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
\\
\\
20\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
\\
4\\
20\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
\\
\\
80\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
\\
9\\
80\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
7\\
9\\
80\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
\\
16\\
80\\
\hline
\end{tabular}~~
\begin{tabular}{|c|}
\\
\\
5\\
\hline
\end{tabular}

\section{Complexité}\label{complexite}


\section{Dérécursification}\label{derecur}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la dérécursification de la fonction hexa_dec_rec()
% Attention, il n'est pas question ici de fournir un algorithme itératif mais
% bien d'éliminer la récursivité comme cela a été vu au cours.
% La solution doit être proposée en utilisant le pseudo-code vu au cours (et
% dans les GameCodes du Chapitre 9).
%

\end{document}
