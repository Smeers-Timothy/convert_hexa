\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath,mathtools}
\usepackage{empheq}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage[hidelinks]{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=magenta,
urlcolor=cyan,
pdfpagemode=FullScreen,
}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw,dvipsnames]{xcolor}

% Change le nom par défaut des listing
\renewcommand{\lstlistingname}{Extrait de Code}

% Change la police des titres pour convenir à votre seul lecteur
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape}
% Idem pour la table des matière.
\usepackage[nottoc,notlof,notlot]{tocbibind}
\usepackage[titles,subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}

\newcommand{\coms}[1]{\textcolor{MidnightBlue}{#1}}

\lstset{
    language=C, % Utilisation du langage C
    commentstyle={\color{MidnightBlue}}, % Couleur des commentaires
    frame=single, % Entoure le code d'un joli cadre
    rulecolor=\color{black}, % Couleur de la ligne qui forme le cadre
    stringstyle=\color{RawSienna}, % Couleur des chaines de caractères
    numbers=left, % Ajoute une numérotation des lignes à gauche
    numbersep=5pt, % Distance entre les numérots de lignes et le code
    numberstyle=\tiny\color{mygray}, % Couleur des numéros de lignes
    basicstyle=\tt\footnotesize,
    tabsize=3, % Largeur des tabulations par défaut
    keywordstyle=\tt\bf\footnotesize\color{Sepia}, % Style des mots-clés
    extendedchars=true,
    captionpos=b, % sets the caption-position to bottom
    texcl=true, % Commentaires sur une ligne interprétés en Latex
    showstringspaces=false, % Ne montre pas les espace dans les chaines de caractères
    escapeinside={(>}{<)}, % Permet de mettre du latex entre des <( et )>.
    inputencoding=utf8,
    literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\newcommand{\tablemat}{~}

%%%%%%%%%%%%%%%%% TITRE %%%%%%%%%%%%%%%%
% Complétez et décommentez les définitions de macros suivantes :
\newcommand{\intitule}{Projet 3 (Récursivité \& Élimination de la Récursivité)}
\newcommand{\Prenom}{Timothy}
\newcommand{\Nom}{Smeers}
\newcommand{\matricule}{S200930}
% Décommentez ceci si vous voulez une table des matières :
\renewcommand{\tablemat}{\tableofcontents}

%%%%%%%% ZONE PROTÉGÉE : MODIFIEZ UNE DES DIX PROCHAINES %%%%%%%%
%%%%%%%%            LIGNES POUR PERDRE 2 PTS.            %%%%%%%%
\title{INFO0947: \intitule}
\author{\textsc{\Prenom}~\textsc{\Nom}, \matricule}
\date{}

\begin{document}
\maketitle
\newpage
\tablemat
\newpage
%%%%%%%%%%%%%%%%%%%% FIN DE LA ZONE PROTÉGÉE %%%%%%%%%%%%%%%%%%%%




%----------------------------------------Formulation Récursive.----------------------------------------%
\section{Formulation Récursive.}\label{formulation}

	%----------------------------------------Notations.----------------------------------------%
	\subsection{Notations.}	
	
	$\forall ~ n ~ \in \mathbb{N} ~ , ~ n > 0 $
	\vspace{2mm}
	
	$\forall ~ case ~ \in ~ hexa ~ , ~ \exists ~ case ~ \in ~ \{0, 1, \ldots , 9, A, B, \ldots , F\}$
	\vspace{2mm}
	
	$\exists ~ l\_nextCase ~ \in ~ hexa[] ~ , ~ l\_nextCase ~ = ~ hexa ~ + ~ 1 $
	\vspace{2mm}
	
	$\exists ~ l\_position ~ \in ~ \mathbb{N} ~ , ~ l\_position = n - 1$
	\vspace{2mm}
	
	$\exists ~ l\_exposant ~ \in ~ \mathbb{N} , l\_exposant = hexa\_power(l\_position);$
	\vspace{2mm}
	
	$\exists ~ (l\_convert)_{10} ~ \in ~ \mathbb{N} ~ , ~ (l\_convert)_{10} = convert(hexa[l\_position]) $
	\vspace{2mm}
	
	$\exists ~ (l\_decimal)_{10} ~ \in ~ \mathbb{N} ~ , ~ (l\_decimal)_{10} = (l\_convert)_{10} * (l\_exposant)_{10}$
	\vspace{2mm}
	
	%----------------------------------------Peut-on résoudre le problème récursivement ?----------------------------------------%
	\subsection{Peut-on résoudre le problème récursivement ?}
	
		\begin{itemize}
			\item[$\bullet$] Trois questions
			\begin{enumerate}
				\item Peut-on trouver un paramètre récursif ?
				\begin{itemize}
					\item[$\triangleright$] n
				\end{itemize}
				\item Peut-on trouver un cas de base$^{\ref{cas_base}}$ ?
				\begin{itemize}
					\item[$\triangleright$] $n = 1$
				\end{itemize}
				\item Peut-on exprimer le problème de manière récursive$^{\ref{cas_recur}}$ ?
				\begin{itemize}
					\item[$\triangleright$] Pour $decimal \in (\mathbb{N})_{10}$, on a
				\end{itemize}
			\end{enumerate} 
		\end{itemize}
		
		$
		(l\_decimal)_{10} = \left\{
    	\begin{array}{ll}
        		l\_decimal & \mbox{si n = 1}  \\
        		l\_decimal + hexa\_dec\_rec(l\_nextCase, l\_position) & \mbox{sinon.}
    	\end{array}
		\right.
		$
	
	%----------------------------------------Cas de base.----------------------------------------%
	\subsection{Cas de base.}\label{cas_base}
	
		\begin{itemize}
			\item[$\bullet$] L'expression \fbox{$ n == 1$} est la condition de terminaison.
			\item[$\bullet$] L'instruction \fbox{$return (l\_decimal);$} est le cas de base.
			\item[$\bullet$] L'instruction \fbox{$return (l\_decimal + (hexa\_dec\_rec(l\_nextCase, l\_position)));$} est 
							\\ l’appel récursif.
			\begin{itemize}
				\item[$\triangleright$] Puisqu’on dispose d’une invocation de la fonction $\textbf{hexa\_dec\_rec()}$ sur des 
										\\ paramètres effectif différent 
										\\ des paramètres formel $\textbf{(l\_position < n \&\& l\_nextCase > hexa)}$ 
										\\ Dit autrement, chaque appel récursif tend vers le cas de base.
			\end{itemize}
		\end{itemize}
	
	%----------------------------------------Cas récursif.----------------------------------------%
	\subsection{Cas récursif.}\label{cas_recur}
	
		Nos cas récursif sont donc $\textbf{l\_position}$ et $\textbf{l\_nextCase}$ car :
		\\
		
		\begin{tabular}{|p{15cm}|c}
			\hline
			La conversion de $\textbf{hexa}$ vaut $\textbf{l\_decimal}$ si $\textbf{n = 1}$. Sinon, c'est $\textbf{l\_decimal}$ additioné par 
			\\ la conversion de $\textbf{l\_nextCase}$ dont la taille restante vaut $\textbf{l\_position}$.
			\\
			\hline
		\end{tabular}
		\\
		
		Mathématiquement, cela donne :
		\vspace{2mm}
		
			$
			(l\_decimal)_{10} = \left\{
	    	\begin{array}{ll}
	        		l\_decimal & \mbox{si n = 1}  \\
	        		l\_decimal + hexa\_dec\_rec(l\_nextCase, l\_position) & \mbox{sinon.}
	    	\end{array}
			\right.
			$
		
%----------------------------------------Spécifications.----------------------------------------%
\section{Spécifications.}\label{specification}

	\begin{center}
		\begin{tabular}{|p{17cm}|c}
			\hline
			\\
			Une spécification se définit en deux temps :
			\vspace{3mm}
		
			\textbf{La PréCondition}  implémente les suppositions. Elle caractérise donc les conditions initiales du module,
			\\ les propriétés que doivent respecter les valeurs en entrée du module.
			\\ Elle se définit donc sur les paramètres formels (qui seront initialisés avec les paramètres effectifs). 
			\\ La PréCondition doit être satisfaite avant l’exécution du module.
			
			\vspace{3mm}
			
			\textbf{La PostCondition} implémente les certifications. Elle caractérise les conditions finales du résultat du
			\\ module. Dit autrement, la PostCondition décrit le résultat du module sans dire comment il a été 
			\\ obtenu. La PostCondition sera satisfaite après l’invocation.

			\\
			\hline
		\end{tabular}
	\end{center}
		
	\vspace{5mm}
	
	\begin{itemize}
		\item[$\bullet$] PréCondition $\equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} \wedge hexa[0 \ldots  n-1] init \Rightarrow hexa ~ init$
		
		\vspace{3mm}
		\begin{itemize}
			\item[$\triangleright$] Dans ce cas de figure, ma fonction contient $2$ assert qui sont représenté ci-dessus. 
						   \\La première condition est que mon String soit différent de null. 
						   \\Ensuite, il faut que mon `n` soit strictement supérieur à $0$ car dans le cas contraire cela veux 
						   	 dire que mon String ne contient aucun symbole.
						   \\hexa doit bien entendu être initialisé. Cette notation est peut-être redondante mais je tiens tout de même à le préciser.					
		\end{itemize}
		\vspace{5mm}
		
		\item[$\bullet$] PostCondition $\equiv (hexa\_dec\_rec)_{10} = Hexa\_Dec\_Rec(hexa, n) 
									 \\ \wedge hexa = hexa_0 \wedge n \neq n_0$
			
		\vspace{3mm}
		\begin{itemize}
			\item[$\triangleright$] Le résultat de ce module devra comprendre les certifications suivante : 
			\begin{itemize}
				\item[$\star$] $hexa = hexa_0$ Ne signifie seulement que le String n'a pas changer.
							   \\ Cependant, nous déplaçons le pointeur sur le String.
				\item[$\star$] $n \neq n_0$ Dans ce cas de figure, nous ne modifions pas la taille du String mais nous décrémentons la valeur de $n$ pour
					  pouvoir parcourir hexa de la position $0$ à la position $n-1$ .
			\end{itemize} 				
		\end{itemize}
	\end{itemize}
		
% Spécification %
	\begin{lstlisting}[caption={Spécification}]
/*
 * PréCondition   (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} \wedge hexa[0 \ldots  n-1] init \wedge hexa[0 \ldots  n-1] init  $}<) 
 * 				  (>\coms{$  \Rightarrow hexa ~ init																								  $}<) 
 * 
 * PostCondition  (>\coms{$  \equiv (hexa\_dec\_rec)_{10} = Hexa\_Dec\_Rec(hexa, n)  \wedge hexa = hexa_0 \wedge n \neq n_0							  $}<)
 */
unsigned int hexa_dec_rec(char *hexa, int n);

	\end{lstlisting}

\newpage

%----------------------------------------Construction Récursive.----------------------------------------%
\section{Construction Récursive.}\label{recur}

	Vu que notre fonction $\textbf{hexa\_dec\_rec()}$ est une fonction récursive qui s'appuie sur une structure conditionnelle, 
	alors il nous faut une approche constructive en trois étapes
	
	\begin{enumerate}
		\item Programmation défensive.
		\item Cas de base.
		\item Cas récursif.
	\end{enumerate} 
	
	%----------------------------------------Programmation défensive.----------------------------------------%
	\subsection{Programmation défensive.}
	
		Il s'agit d'une vérification de la PréCondition.

% hexa_dec_rec %
		\begin{lstlisting}[caption={hexa\_dec\_rec()}]
unsigned int hexa_dec_rec(char *hexa, int n) {
	assert(hexa);
	assert(n > 0);

    /* PréCondition (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} ~\wedge~ hexa[0 \ldots  n-1] init ~\wedge~ hexa[0 \ldots  n-1] init 	$}<)
					(>\coms{$  \Rightarrow hexa ~ init 																										$}<) */
	
	... /* Reste du code */
}

		\end{lstlisting}
		
	%----------------------------------------Cas de base.----------------------------------------%
	\subsection{Cas de base.}\label{cas_base_code}
	
	
	On gère le cas de base où $n = 1$. Juste avant, on gère les cas précis de la préconditon$^{\ref{specification}}$
	
% Cas de base %
		\begin{lstlisting}[caption={Cas de base}]
	/* PréCondition (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} ~\wedge~ hexa[0 \ldots  n-1] init ~\wedge~ hexa[0 \ldots  n-1] init  $}<)
	 				(>\coms{$  \Rightarrow hexa ~ init																										$}<) */

	if (n == 1)
		/* (>\coms{$ \{n = 1 \Rightarrow hexa \neq NULL\} $}<) */
		return (l_decimal);
		/* (>\coms{$  \{n = n_0 \wedge hexa = hexa_0 \wedge hexa\_dec\_rec = l\_decimal\}  $}<) */
		/* (>\coms{$  \{\Rightarrow POSTCONDITION\}  $}<) */

		\end{lstlisting}
				
	%----------------------------------------Cas récursif.----------------------------------------%
	\subsection{Cas récursif.}
	
		On gère le cas de base où $n > 1$. Juste avant, on gère les cas précis du cas de base $^{\ref{cas_base_code}}$ et de la précondition$^{\ref{specification}}$

% Cas récursif %
		\begin{lstlisting}[caption={Cas récursif}]
	/* PréCondition (>\coms{$ \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} ~\wedge~ hexa[0 \ldots  n-1] init ~\wedge~ hexa[0 \ldots  n-1] init 	$}<)
	 	  		    (>\coms{$ \Rightarrow hexa ~ init 																										$}<) */

	/* (>\coms{$ \{n > 1 \Rightarrow hexa \neq NULL\} $}<) */
	return (l_decimal + (hexa_dec_rec(l_nextCase, l_position)));
	/* (>\coms{$  \{n \neq n_0 \wedge hexa = hexa_0 \wedge hexa\_dec\_rec = l\_decimal + (hexa\_dec\_rec(l\_nextCase, l\_position))\}  $}<) */
	/* (>\coms{$  \{\Rightarrow POSTCONDITION\}  $}<) */

		\end{lstlisting}

%----------------------------------------Traces d'Exécution----------------------------------------%
\section{Traces d'Exécution.}\label{traces}

	Soit l'exemple $\textbf{hexa\_dec\_rec(char *hexa, int n)}$ noté $\textbf{f(s,n)}$ 
	\\ On doit indiquer la trace de l’algorithme, sur la Pile, pour la récursivité suivante :  
	\\ $\textbf{l\_decimal + (hexa\_dec\_rec(l\_nextCase, l\_position))}$
	\\ Ce qui donne l'expression sous forme postfixée : $\textbf{f(s,n) f(s1+,n1-)+}$
	\\

	\begin{itemize}
		
% FIRST ITEM %
		\item[$\bullet$] Soit l'exemple $\textbf{f('27', 2)}$
		\\
	
		\begin{center}
			\begin{tabular}{|c|}
				\\
				\\
				\textcolor{white}{--}\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				\\
				32\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				f(7,1)\\
				32\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				7\\
				32\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				\\
				39\\
				\hline
			\end{tabular}~
		\end{center}
		
		\vspace{5mm}
% SECOND ITEM %
		\item[$\bullet$]Soit l'exemple $\textbf{f('A23', 3)}$
		\\
		
		\begin{center}
		
			\begin{tabular}{|c|}
				\\
				\\
				\textcolor{white}{--}\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				\\
				2560\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				f(23,2)\\
				2560\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				f(3,1)\\
				f(23,2)\\
				2560\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				3\\
				f(23,2)\\
				2560\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				3\\
				32\\
				2560\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				35\\
				2560\\
				\hline
			\end{tabular}~
			\begin{tabular}{|c|}
				\\
				\\
				2595\\
				\hline
			\end{tabular}~
		\end{center}
				
		\vspace{5mm}
% THIRD ITEM %
		\item[$\bullet$] Soit l'exemple $\textbf{f('A78E', 4)}$
	\end{itemize}
	
	\begin{center}
	
		\begin{tabular}{|c|}
			\\
			\\
			\\
			\textcolor{white}{--}\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			\\
			\\
			\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			\\
			\\
			f(78E,3)\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			\\
			f(8E,2)\\
			f(78E,3)\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			f(E,1)\\
			f(8E,2)\\
			f(78E,3)\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			14\\
			f(8E,2)\\
			f(78E,3)\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			14\\
			128\\
			f(78E,3)\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			14\\
			128\\
			1792\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			\\
			142\\
			1792\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			\\
			\\
			1934\\
			40960\\
			\hline
		\end{tabular}~
		\begin{tabular}{|c|}
			\\
			\\
			\\
			42894\\
			\hline
		\end{tabular}~
	\end{center}
	
	\newpage
		
%----------------------------------------Complexité.----------------------------------------%
\section{Complexité.}\label{complexite}

% hexa_dec_rec() %
		\begin{lstlisting}[caption={hexa\_dec\_rec()}]
/**
 * @fn unsigned int hexa_dec_rec(char*, int)
 * @brief Convertir un nombre hexadécimal en nombre décimal
 *
 * @pre (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} ~\wedge~ hexa[0 \ldots  n-1] init ~\wedge~ hexa[0 \ldots  n-1] init $}<)
 * 		(>\coms{$  \Rightarrow hexa ~ init	$}<)
 * @post (>\coms{$ \equiv (hexa\_dec\_rec)_{10} = Hexa\_Dec\_Rec(hexa, n)  \wedge hexa = hexa_0 \wedge n \neq n_0	$}<)
 * @param hexa, le nombre hexadécimal
 * @param n, le nombre de symboles dans le nombre hexadécimal
 * @return la représentation décimale du nombre hexadécimal.
 */
unsigned int hexa_dec_rec(char *hexa, int n) {
	assert(hexa);
	assert(n > 0);

	char *l_nextCase;
	unsigned int l_convert;
	unsigned int l_position;
	unsigned int l_decimal;
	unsigned int l_exposant;

	l_position = n - 1;
	l_nextCase = hexa + 1;
	l_convert = convert(*hexa);
	l_exposant = hexa_power(l_position);
	l_decimal = l_convert * l_exposant;

	if (n == 1)
		return (l_decimal);

	return (l_decimal + (hexa_dec_rec(l_nextCase, l_position)));
}

		\end{lstlisting}

% T(a) %
		\begin{lstlisting}[caption={T(a)}]
	l_position = n - 1;							//											
	l_nextCase = hexa + 1;						//					
	l_convert = convert(*hexa);				//	T(a)				
	l_exposant = hexa_power(l_position);	//			
	l_decimal = l_convert * l_exposant;		//
	
		\end{lstlisting}

% T(a') %
		\begin{lstlisting}[caption={T(a')}]
	if (n == 1)							//	T(a')											
		return (l_decimal);			//
		
		\end{lstlisting}

% T(s+1,n+1) %
		\begin{lstlisting}[caption={T(s+1,n+1)}]
	return (l_decimal + (hexa_dec_rec(l_nextCase, l_position))); // T(s+1,n+1)
	
		\end{lstlisting}
		
\newpage

	Soit $T_{(n)}$, le coût d’un appel à $hexa\_dec\_rec(s, n)$.
	\\En ce qui concerne le cas de base, on va dire qu’il prend $T_{(a)}$ opérations, $T_{(a)}$ étant constant. 
	\\Pour ce qui est du cas récursif, il prend également $T_{(a)}$ opérations ainsi que le nombre d’opérations 
	\\ nécessaires par l’appel récursif, c'est-à-dire $T_{(s + 1 , n - 1)}$. Il vient donc le sustème suivant :
	\\
	
	$
	T_{(n)} = \left\{
    \begin{array}{ll}
        	T_{(a)} + T_{(a')} & \mbox{si n = 1}  \\
        	T_{(a)} + T_{(s + 1 , n-1)} & \mbox{sinon.}
    \end{array}
	\right.
	$
	\\
	
	L'élimination de proche en proche consiste à réécrire plusieurs fois cette équation en utilisant le cas
	récursif afin de faire apparaitre un motif reconnaissable.
	\\
	
	\begin{empheq}[box=\fbox]{align*}
		T_{(n)} &= T_{(a)} + T_{(s + 1 , n - 1)} \\
				&= T_{(a)} + T_{(a)} + T_{(s + 2 , n - 2)} \\
				&= T_{(a)} + T_{(a)} + T_{(s + 2 , n - 2)} \\
				&= 2T_{(a)} + T_{(s + 2 , n - 2)} \\
				&= 3T_{(a)} + T_{(s + 3 , n - 3)} \\
				&= \ldots \\
				&= k \times T_{(a)} + T_{(s + k , n - k)}
	\end{empheq}
	

	
	$T_{(n - k)}$ est une formulation tout à fait générale du temps d'exécution du $k^e$ appel récursif. On ne connait 
	qu'une valeur particulière de $T_{(\cdot)}$ : $T_{(1)} = 0$. On va donc essayer de faire apparaitre cette valeur particulière.
	On a :
	
	\begin{empheq}[box=\fbox]{align*}
		n - k &= 1 \\
		-k &= 1 - n \\
		k &= n - 1
	\end{empheq}
		
	On insère cette valeur dans $k \times T_{(a)} + T_{(s + k , n - k)}$ , et il vient: \\
	
	\fbox{$T_{(n)} = (n - 1) \times T_{(a)} + T_{(s + (n - 1))} \in \mathcal{O}_{(n)}$}
	\\
	
	Nous avons donc une complexité d’ordre Linéaire.

%----------------------------------------Dérécursification.----------------------------------------%
\section{Dérécursification.}\label{derecur}

	%----------------------------------------Algorithme de transformation non-terminale.----------------------------------------%
	\subsection{Algorithme de transformation non-terminale.}
		Voici les étapes à suivre pour transformer une fonction récursive non-terminale en une fonction récursive
		terminale :
		
		\begin{enumerate}
			
			\item Vérifier que l'opérateur $\alpha$ est commutative et associative.
				\begin{itemize}
					\item[$\bullet$] commutatif
					\begin{itemize}
						\item[$\triangleright$] $x + y = y + x $
					\end{itemize}
										
					\item[$\bullet$] associatif
					\begin{itemize}
						\item[$\triangleright$] $x + (y + z) = (x + y) + z$
					\end{itemize}
				\end{itemize}
				
				
			\item Créer une fonction $\lambda$ pour transformer la récursivité non-terminale en récursivité terminale, avec plus
				  de paramètres (dont un (ou plusieurs) accumulateur·s).
				  
% lambda\_1 %
				\begin{lstlisting}[caption={lambda\_1}]
(>{$ \lambda $}<)(String h, int n, int nAccu):

				\end{lstlisting}
			
			
			\item Déterminer les paramètres effectifs de $\lambda$ : la fonction qui appelle $\lambda$ lui passe ses paramètres et initalise
					les accumulateurs;

% lambda\_2 %		
				\begin{lstlisting}[caption={lambda\_2}]
(>{$ \lambda $}<)(String h, int n, int nAccu):
		c;
		e;
		a;
		d;
		
				\end{lstlisting}
					
					
			\item Écrire le corps de la fonction $\lambda$ :
				\begin{itemize}
					\item[$\bullet$] Les résultat à renvoyer lors du cas de base dépend maintenant de l'(des) accumulateur·s;
					\item[$\bullet$] Les opérations intermédiaires sont maintenant effectuées sur l'(les) accumulateur·s.
				\end{itemize}

% lambda\_3 %	
			\begin{lstlisting}[caption={lambda\_3}]
(>{$ \lambda $}<)(String h, int n, int nAccu):
				 
		c (>{$ \leftarrow $}<) convert(h[0]);
		e (>{$ \leftarrow $}<) hexa_power(nAccu - 1);
		a (>{$ \leftarrow $}<) c * e;
		
		if( n = 1)
			then 
				d (>{$ \leftarrow $}<) c;
			else
				d (>{$ \leftarrow $}<) (>{$ \lambda $}<)( h+1, n-1, a);
		
			\end{lstlisting}
				
					Les conditions de terminaisons et des différents cas récursifs ne changent pas.
					\\ Ensuite, il faut dérécursiver $\lambda$ en se référant aux étapes de \hyperref[terminale]{l'algorithme de transformation terminale}.
		\end{enumerate}	
		
		
		
		
	%----------------------------------------Algorithme de transformation terminale.----------------------------------------%
	\subsection{Algorithme de transformation terminale.}\label{terminale}
	
		\begin{enumerate}
			\item Commencer la définition d'une fonction ayant les mêmes paramètres formels, 
					\\PRÉCONDITION et POSTCONDITION que le fonction d'origine.
					
% terminale\_1 %	
			\begin{lstlisting}[caption={terminale\_1}]
/*
 * PréCondition   (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} \wedge hexa[0 \ldots  n-1] init \wedge hexa[0 \ldots  n-1] init  $}<) 
 * 				  (>\coms{$  \Rightarrow hexa ~ init																								  $}<) 
 * 
 * PostCondition  (>\coms{$  \equiv (hexa\_dec\_rec)_{10} = Hexa\_Dec\_Rec(hexa, n)  \wedge hexa = hexa_0 \wedge n \neq n_0							  $}<)
 */
f(>{$'$}<)(String hexa, int n):

			\end{lstlisting}
			
\newpage
			\item Pour chaque variable, introduire une nouvelle variable synonyme.
		
% terminale\_2 %	
			\begin{lstlisting}[caption={terminale\_2}]
f(>{$'$}<)(String hexa, int n):

	m (>{$ \leftarrow $}<) n;
	g (>{$ \leftarrow $}<) hexa;
	a (>{$ \leftarrow $}<) 0;

			\end{lstlisting}
			
			\item Commencer la rédaction de la boucle $\textbf{until}$ en prenant comme Critère d'Arrêt, 
					\\la condition terminaison. Dans la condition, il faut évidemment remplacer les variables par leurs synonymes.

% terminale\_3 %				
			\begin{lstlisting}[caption={terminale\_3}]
f(>{$'$}<)(String hexa, int n):

	m (>{$ \leftarrow $}<) n;
	g (>{$ \leftarrow $}<) hexa;
	a (>{$ \leftarrow $}<) 0;
	
	until m = 1 do

	end
			\end{lstlisting}
			
			\item On poursuit par l'écriture du Corps de la Boucle. On recopie les opérations faites sur les variables avant l'appel récursif 
					avec les synonymes des variables.
					
			\item On finit le Corps de la Boucle par les instructions de progression. En identifiant, dans l'appel récursif les modifications qui sont effectuées
					sur chaque variables lors de l'appel et les recopier en fin de boucle.
					
% terminale\_4 %					
			\begin{lstlisting}[caption={terminale\_4}]
f(>{$'$}<)(String hexa, int n):

	m (>{$ \leftarrow $}<) n;
	g (>{$ \leftarrow $}<) hexa;
	a (>{$ \leftarrow $}<) 0;
	
	until m = 1 do
		g (>{$ \leftarrow $}<) g + 1;
		c (>{$ \leftarrow $}<) convert(g[0]);
		m (>{$ \leftarrow $}<) m - 1;
		e (>{$ \leftarrow $}<) hexa_power(m);
	end

			\end{lstlisting} 

\newpage

			\item Après la boucle, on retourne la valeur calculée par les opérations faites dans le cas de base de la fonction récursive.
					Sans oublier le changement de variables par les synonymes.

% terminale\_5 %
			\begin{lstlisting}[caption={fonction non récursive}]
/*
 * PréCondition   (>\coms{$  \equiv (hexa \neq NULL) \wedge n > 0 , n \in \mathbb{N} \wedge hexa[0 \ldots  n-1] init \wedge hexa[0 \ldots  n-1] init  $}<) 
 * 				  (>\coms{$  \Rightarrow hexa ~ init																								  $}<) 
 * 
 * PostCondition  (>\coms{$  \equiv (hexa\_dec\_rec)_{10} = Hexa\_Dec\_Rec(hexa, n)  \wedge hexa = hexa_0 \wedge n \neq n_0							  $}<)
 */
f(>{$'$}<)(String hexa, int n):

	m (>{$ \leftarrow $}<) n;
	g (>{$ \leftarrow $}<) hexa;
	a (>{$ \leftarrow $}<) 0;
	
	until m = 1 do
		g (>{$ \leftarrow $}<) g + 1;
		c (>{$ \leftarrow $}<) convert(g[0]);
		e (>{$ \leftarrow $}<) hexa_power(m - 1);
		m (>{$ \leftarrow $}<) m - 1;
	end
	r (>{$ \leftarrow $}<) convert(g[0]);

			\end{lstlisting}
		\end{enumerate}
		
\end{document}